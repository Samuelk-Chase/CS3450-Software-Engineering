AI Note: This Design document was created with the assistance of ChatGpt.
# Group 5: High-Level Design Document: The Last Game

 ### **Design Summary:**

This design document outlines the architecture, security measures, and user interface for "The Last Game", a roguelike RPG card-based game where content is generated by AI to provide a unique user experience. Our design integrates multiple components for a seamless player experience. The database design ensures the persistence of user data, including game state, card collections, and transaction records, with robust relationships between entities like users, cards, and combat encounters. The game system includes interfaces for internal components, such as game logic, card management, and transaction tracking, and external systems like OAuth authentication, Stripe payment processing, and AI-driven content generation (for cards and story progression). These interfaces work in tandem to provide a smooth and responsive user experience.

Security is prioritized throughout the design with encryption, token-based authentication, and anti-cheat mechanisms to protect player data and game integrity. The possible multiplayer experience is safeguarded against exploits and DDoS attacks, and user privacy is ensured through anonymized data and secure communication protocols. The UI is designed with a modern aesthetic and responsive layout, leveraging a customizable theme system powered by AI. The game will run on web platforms with support for desktop and tablet browsers, offering an engaging and dynamic gameplay experience while ensuring reliable communication with both internal and external components for features like user management, transactions, and content generation. See table of contents to dive more into the details of our design.


## Table Of Contents
1. Stakeholder Expectations

2. Game Design

3. System overview

   
4. Backend Design

   
   4.1 Internal Interfaces
   
      1. User Authentication Interface
      2. Game Engine Interface
      3. Card Management Interface
      4. Payment Interface
      5. AI Image Generation Interface
      6. AI-Language Model Interface
         
   4.2 External Interfaces
   
      1. Stripe
      2. AI Language Model
      3. AI Image Generator service
      4. Database with Supabase
      5. OAuth
         
5. Database Design
   
      1. Actions and Responsibilities
      2. Communication with other Components
      3. Tables and Entities
  
   
6. Risks and Security Design
    
    1. Authentication and Authorization
    2. Data Protection and Privacy
    3. Payment Security with Stripe
    4. Mitigating Common Attacks
    5. Secure Multiplayer and Fairplay
    6. Disaster Recover & Incident Response
    
   
7. UI Design
   
   1. Hardware Platform
   2. User Interface Design
   3. UI Flow
   4. Input/Output Processing
   5. Component Architecture
   6. Implementation Strategy
   

## **1 . Stakeholder Expectations:**


### **i.** **Game Players:**

   - **Engagement & Enjoyment:** Players expect an immersive and evolving gaming experience powered by AI. The AI-generated stories should feel dynamic, with player choices significantly impacting the narrative, ensuring replayability.
     
   - **Customization & Progression:** The card collection system should feel unique for each player based on the story they are experiencing. Players want to see meaningful rewards tied to their in-game actions and feel a sense of accomplishment.
     
   - **Visual Appeal:** Players expect unique card visuals that are generated through AI, adding to the game's charm and personalization. UI should be easy to navigate and use.
     
   - **Security & Privacy:** Players are concerned about the security of their data, especially during payments and personal information storage. They expect a secure authentication process (OAuth) and protection of their game history and progress.
     
   - **Accessibility & Convenience:** Players expect easy access to the game through a web interface, intuitive game flow, and secure sign-ins without the need for managing multiple passwords.

### **ii.** **Game Developers/Operators:**

   - **Scalability & Flexibility:** The development team expects the system to be easily scalable and flexible for future feature expansion, such as adding more cards, boss battles, or in-game events.
     
   - **Maintainability:** Developers expect the system to be modular, with clear separation of concerns between the client-side and server-side components, facilitating maintenance and bug fixes.
     
   - **Security & Compliance:** The security design, including encryption, fraud protection, and adherence to privacy regulations, is crucial for the development team to ensure compliance and protect user data.
     
   - **External Service Integration:** Developers expect seamless integration with third-party services (Stripe, AI models, OAuth) for payment processing, authentication, and story generation.

### **iii.** **Business Stakeholders (Product Owners/Investors):**

   - **Monetization & Payment Handling:** Business stakeholders expect the integration with Stripe to support seamless in-game purchases, ensuring a reliable and secure transaction process for users, with potential for future monetization.
     
   - **User Acquisition & Retention:** Business stakeholders expect the game’s dynamic content and personalized experiences (via AI) to drive player engagement, retention, and growth. The game’s potential to scale should allow for new content and features that can attract and retain a large user base.
     
   - **Analytics & Data Management:** Stakeholders expect robust analytics on user behavior, progress, and in-game purchases, allowing for data-driven decision-making and targeted updates or new features.
     
   - **Security & Trust:** Business stakeholders are also invested in the system’s security and the reputation of the platform. Protecting user data and ensuring safe gameplay experiences is essential for maintaining user trust and preventing any negative public relations or financial impact from security breaches.


Overall, each stakeholder group expects a seamless, secure, and engaging experience, with a system designed for scalability and ease of expansion.


## 2. Game Design


### Glossary (**Bolded** words are defined here)

- *AI-driven* - All content will be generated by AI dynamically, based on the user's actions.<a name="AI-driven"></a>
- *Roguelike* - Death will be permanent, meaning the player will restart from scratch upon each death.
- *Deckbuilding* - Combat will be card-based, and the player will collect new cards, increasing the size of their deck as they play through scenarios.
- *Run* - A single playthrough of the game, from beginning to death.
- *Mana* - What the player uses to play cards. 
  - Each card has an associated mana cost.
- *Attack* - A type of card that deals damage and possibly applies status effects.
- *Ability* - A type of card that performs a one-time action.
- *Power* - A type of card that applies an effect that lasts for the rest of the combat.
- *Keyword* - See [Game Rules](#game-rules) for more info.

### Game Overview


**Last Game** will be an **AI-driven**, dynamic **roguelike** **deckbuilding** game.


- *Gameplay*  
  - The player will be faced with decisions and will be prompted by the AI to influence events and play through scenarios.
    - These scenarios will develop the story and also serve to increase the player's resources for combat.
  - The player will be placed in combat, and they will fight against enemies using the cards in their deck.
  - The player will be allowed to play for as long as they want to, without a specific end in mind.
    
- *Modes*
  - The main game mode will be a single-player campaign mode.
  - There will also be a multiplayer co-op mode that will allow two or more users to simultaneously play in the same game instance.


### Gameplay Mechanics


- *Text Interaction* 
  - The user will interact with the AI through a text entry box.
  - The AI will give the user a scenario and ask the user what their character will do.
    - This could consist of a binary choice or an open-ended prompt.
  - The AI will respond to the user's prompt and dynamically generate new content based on previous input.
  - The AI should be able to respond to any input the user gives, even if that input attempts to do something unrealistic.
    
- *Combat*
  - Combat will be turn-based
    - The player will always go first
      - With multiple players, the order is arbitrary, but enemies go last.
    - A turn will consist of the player playing various cards within the limits of their **mana**.
    - A player will select an "End Turn" button when they are ready to move on.
    - The player may play as many actions as they wish, as long as they don't exceed their **mana** reserve.     
  - Combat can end upon meeting one of two conditions:
    - The player's health reaches 0
    - All enemies' health is reduced to 0
  - The player should be able to see a card's description by clicking on it.
  - The player can play a card by dragging it upwards into the play area.
  - The player should be able to see their total and current **mana**.

  
![Example UI](../doc/images/combat_ui_example.jpg)
Example of how UI and gameplay will look


- *Cards*
  - Cards will have several consistent features, and will always fit within certain rules:
    - Cards will have an associated **mana** cost.
    - Cards will have a title.
    - Cards will have a picture.
    - Cards will have one of the following attributes:
      - **Attack** 
      - **Ability** 
      - **Power** 
    - Cards will have a description.
      - This description will include any associated **keywords** in a distinct font.
      - The player should be able to hover over any **keywords** and a description of that **keyword** will be displayed.
    - Cards must consistently obey their own descriptions when played.

   
### Game Rules


- *Death*
  - When a player reaches 0hp, they die and must restart the game.
- *Gaining Cards*
  - The AI will generate three options for the player to choose from each time they complete combat.
  - The player will be able to gain cards when the AI allows them to during text prompt (non-combat) scenarios
    
- **Keywords**
  - Keywords are certain words that the AI understands have an exact, consistent meaning.
  - These keywords can range from 
  - Some keywords that we will implement are:
    - Base Effects
      - **Damage** - The attack will deal `n` damage to the target
      - **Defense** - The target will receive `n` block until their next turn
    - Status Effects
      - **Stunned** - The target will lose their next `n` turns
      - **Confused** - The target has a 50% chance to miss any attack for `n` turns
      - **Invincible** - The target is invulnerable to damage for `n` turns
      - **Exposed** - The target takes 25% more damage for `n` turns
      - **Weakened** - The target deals 25% less damage for `n` turns
      - **Slowed** - The target gains 25% less block for `n` turns
    - Buffs
      - **Strength** - The target deals `n` more damage until the end of combat
      - **Speed** - The target gains `n` more block until the end of combat
  - Keywords always produce an expected effect.


## 3. System Overview

The system follows a client-server architecture where the client is a web application that communicates with a backend server to handle game state, user accounts, card collections, payments, and story generation. The server-side logic will be responsible for processing game logic, generating dynamic stories using AI language models, and managing data persistence.



### Key Components

#### **Client (Web Interface)**

- **Frontend (UI)**: Provides users with an interface for interacting with the game, such as creating accounts, initiating game sessions, viewing storylines, and interacting with the game world (e.g., collecting cards, battling bosses).
  
- **Game State Management**: The client stores temporary game states and interactions while interacting with the server to update game progress.

---

#### **Backend (Server)**

- **API Layer**: The server exposes RESTful APIs to facilitate communication with the client. It will be responsible for handling requests like card collection updates, story generation, and game state management. Handled with Game Engine Interface.
  
- **Internal Backend Interfaces**: The core of the backend, which handles the AI-generated story, card interactions and generation, and game logic (including user progress and boss battles).

- **Database**: A relational database to persist game data, user accounts, card collections, game progress, and transaction history (uses Supabase as our database).

---

#### **External Services**

- **Stripe**: For handling payments and purchasing the game.

- **AI Language Model**: An AI-based model that generates stories for the game. This can be an API for a pre-trained model like GPT-4 or a custom language model.

- **AI Image Generation**: An external service to generate card images based on AI models, providing users with unique visual content for the game.

- **OAuth**: For handling authentication and providing extra security for the user. Supabase will be integrated to handle OAuth and authentication.(Handled by Supabase.
  
- **Supabase**: Database used for authentication, storing game state, images, and card data.


### Design Rationale

Client-Server separation ensures a clear division of responsibilities, allowing the backend to manage game logic and storage, while the frontend focuses on delivering an interactive experience. REST APIs provide a standard interface for communication, ensuring scalability and ease of integration with external services (like Stripe and the AI models).

---

## 4. Backend Design



### 4.1 Internal Interfaces

#### i. **User Authentication & Authorization Interface**

- **Purpose**: Validates user authorization using Supabase and OAuth for secure access.
  
- **Actions**:
  - Uses Supabase to validate that the user has permission to access game data, allowing the Game Engine to retrieve user information.
  
- **Communication with Other Interfaces**:
  
  - **Internal**:
    - **Database**: Interacts with the user table to store credentials and securely hash passwords (via Supabase).
    - **Game Engine**: Grants access to the user's game state data after successful validation.
    - **Payment**: Confirms user’s purchase status via the Payment Interface.
      
  - **External**:
    - **Supabase**: Checks access tokens stored in the Supabase database and allows the backend to retrieve user data.
  
- **Rationale**: The User Authentication & Authorization Interface ensures secure user access by checking that a user has a valid access token before granting access to user data. With Supabase managing both OAuth and database storage, this interface will be fairly simple and just check that our Supabase database has authenticated a user before granting access to user data.

---

#### ii. **Game Engine (Story Generation & Game Logic) Interface**


- **Purpose**: Powers dynamic story generation, and manages game flow, player choices, and game logic.

  
- **Actions**:
  - **Story Generation**: Requests internal AI-language model to generate story content.
  - **Handle Player Actions**: Processes player choices (e.g., collecting items, battling bosses).
  - **Card & Buff Management**: Manages cards and buffs during in-game interactions. (The card Management interface is responsible for updating, creating, and returning card actions. The game engine interface is responsible for applying the effects in-game and to the client)
  - **Boss Battle Simulation**: Executes logic for combat and progression.

  
- **Communication with Other Interfaces**:
  - **Internal**:
    - **Card Management**: Gives card details to card management for creating new cards based on player actions. Card management will send back card details and actions.
    - **AI Image Interface**: Requests images for game content like boss fights.
    - **AI-Language Model Interface**: Generates story updates based on player input.
      
  - **External:**
    - **Supabase Database**: Saves player’s progress, permanent game state, and updates inventory during interactions.

  
- **Rationale**: This interface serves as the central hub for game progression. It coordinates between multiple systems (card management, database, story generation) to deliver a consistent experience, keeping the flow of the game intact.

---

#### iii. **Card Management Interface**

- **Purpose**: Handles the collection, use, and upgrades of cards within the game.
  
- **Actions**:
  - **Card Generation**: Creates new cards based on in-game events and item descriptions.
  - **Card Usage**: Allows players to use cards for battles or buffs.
  - **Card Collection**: Tracks and updates the player's card inventory.
  - **Card Upgrades**: Manages potential future upgrades of cards.
  
- **Communication with Other Interfaces**:
  - **Internal**:
    - **Game Engine**: Updates card collection and usage during events.
    - **Database**: Stores card inventory and updates each card's use or collection.
    - **AI Image Generation**: Requests images for newly generated cards.
  
- **Rationale**: By separating card management, the game engine remains focused on game flow, while the Card Management Interface takes care of card creation and updates independently. This allows for easy future expansion of card-related features.

---


#### iv. **Payment Interface (Stripe Integration)**

- **Purpose**: Facilitates in-game purchases and the initial purchase of the game using Stripe.
  
- **Actions**:
  - **Purchase Game**: Handles payment processing through Stripe API.
  - **Transaction History**: Logs purchases to verify user’s game access.
  
- **Communication with Other Interfaces**:
  - **Internal**:
    - **Database**: Stores transaction records and verifies user access.
    - **User Authentication**: Updates user access after a successful payment.
  
- **External**:
  - **Stripe API**: Processes payments and returns transaction statuses.
  
- **Rationale**: A separate Payment Interface allows for clean management of financial transactions. It ensures the game can be easily updated in the future if more payment options are required. This is more of a could-have for us, so it will not be highly prioritized during our implementation. 

---

#### v. **AI Image Generation Interface**

- **Purpose**: Generates custom images for cards and other in-game visuals.
  
- **Actions**:
  - **Card Image Generation**: Requests images based on card attributes.
  - **Image Storage**: Stores generated images to the database.
  - **Boss Image Generation**: Generates visuals for bosses or enemies.
  - **Validation**: Ensures generated images are valid and usable.
  
- **Communication with Other Interfaces**:
  - **Internal**:
    - **Card Management**: Card management requests images for newly generated cards and is sent back image or error.
    - **Game Engine**: The game engine requests images for boss encounters.
   
      
  - **External**:
    - **Image Generation API**: Generates images based on given descriptions.
  
- **Rationale**: This interface isolates image generation to a single component, allowing easy changes and enhancements in the future. It simplifies image management and keeps the logic for visual elements modular. Having logic for image generation separate allows other components to use the interface without needing to know how it works.

---


#### vi. **AI-Language Model Interface**


- **Purpose**: Powers the AI-driven storylines for the game.
  
- **Actions**:
  - **Story Generation**: Generates narrative elements based on game state and user input.
  - **Boss Battle Descriptions**: Provides descriptions for bosses and encounters.
  - **Quality Control/Validation**: Ensures generated stories are in the correct format.
  - **Story Summary**: Provides summaries of major story beats.
  
- **Communication with Other Interfaces**:
  - **Internal**:
    - **Game Engine**: Requests story updates based on user choices.
    - **Database**: Stores story progress and player decisions.
  - **External**:
    - **AI-Language Model API**: Communicates with the LLM to generate dynamic narratives.
  
- **Rationale**: The AI-Language Model is key to the game’s dynamic narrative. Separating this functionality allows easy scalability and flexibility, ensuring stories are generated seamlessly.

---

### 4.2 External Interfaces



#### i. **Stripe Integration**


- **Purpose**: Handles all financial transactions for the game, from initial purchases to in-game purchases.


- **Actions**:
  - Processing and facilitating Payments: Responsible for allowing users to pay for the game.

  
- **Communication**:
  - **Backend → Stripe**: Requests stripe payment.
  - **Stripe → Backend**: Returns transaction status (success/failure).

- **Rationale**: Payment is handled externally to reduce security concerns within the game’s backend. Stripe allows secure, easy payment processing.

---

#### ii. **AI-Language Model (LLM)**

- **Purpose**: Generates dynamic, AI-powered storylines.

- **Actions:**
  - **Generating Story content:** Generates and returns story content based on prompts passed by the backend.
  -  **Generating Item Description:** Will generate descriptions of items that will be used to build cards.

- **Communication**:
  - **Internal AI-Language Model Interface → LLM API**: Sends user input to LLM to generate stories.
  - **LLM → Internal AI-Language Model Interface**: Returns generated story content.

- **Rationale**: By using an external LLM, we can scale and improve the narrative quality without maintaining complex AI models in-house.

---

#### iii. **AI Image Generation Service**

- **Purpose**: Provides unique images for cards and in-game visuals like bosses.

- **Actions:**
  - **Image Generations:** Generates images for in-game entities like cards and bosses/enemies.

  

- **Communication**:
  - **AI image generation internal interface → Image Generation API**: Requests for image creation.
  - **Image Generation API → AI image generation internal interface**: Returns generated image data.

- **Rationale**: Isolating image generation to a single interface allows flexibility in switching image providers or refining visuals in the future. Using external services allows us to avoid needing powerful computers to run the models locally and developing our own custom image model.


---


#### iv. **Database (Supabase)**

- **Purpose**: Provides backend services for user management, including authentication (via OAuth) and game data storage. Manages all persistent data, such as user accounts, game progress, cards, and transaction records using Supabase. See database design for more details.


- **Actions**:
  - **Store User Data**: Saves user credentials (token access) and user profile info.
  - **Store Game State**: Tracks player’s game progress, inventory, decisions, and stats.
  - **Transaction Logs**: Stores all payment transactions and tracks in-game purchases(if implemented in the future).
  - **Game History**: Saves past game sessions to allow users to resume their gameplay.
  - **Card Collection Management**: Stores and updates the player’s card collection.


- **Communication with Other Interfaces**:
  - **Internal**:
    - **User Authentication Interface**: Stores and retrieves user credentials via Supabase authentication. User Authentication interface will check Supabase for user access.
    - **Game Engine**: Retrieves and updates user game state and progress.
    - **Card Management**: Stores and updates player’s card inventory.
    - **Payment Interface**: Stores transactions for purchases and in-game items.
  - **External**:
    - **OAuth**: Will use OAuth providers to authenticate users.

      
- **Rationale**: Supabase provides a powerful backend-as-a-service solution with built-in database management, authentication, and real-time capabilities. By using Supabase for data storage, we can focus on building out the game mechanics and user experience. The **Database Interface** will abstract the complexity of interacting with Supabase, allowing for seamless data management.


- **Communication**:
  - **Backend → Supabase**: Communicates for tasks like sign-up, sign-in, game progress, and transactions.
  - **Supabase → Backend**: Returns user data, game state, and authentication details.


- **Rationale**: Supabase provides a comprehensive, out-of-the-box solution for user management, session handling, and database interactions, allowing us to focus on game development. Its user authentication will allow us to focus on gameplay without sacrificing on security. By using Supabase for data storage, we can focus on building out the game mechanics and user experience.
  

---

#### v. **OAuth Authentication Service**

- **Purpose**: Manages user authentication via OAuth providers (e.g., Google, Facebook) for secure login. (note: Supabase will be responsible for using OAuth)

- **Communication**:
  - **Supabase**: Verifies user and provides session tokens.
  
- **Rationale**: OAuth authentication reduces the overhead of managing user passwords. Supabase will simplify OAuth handling and session management. 

---





### Interface Rationale

We divided our project into these interfaces to separate logic and ensure flexibility. This modular approach will make debugging easier and provide a solid foundation for future feature additions. Each interface is designed to handle a specific concern, ensuring that the overall system remains organized and adaptable.

***Interface Interaction Overview***
![alt text](InterfaceInteractionOverview.png "Main Interface Interactions Overview")



---

## Database Design

### Purpose
Manages all **persistent game data**, integrating with [Supabase](https://supabase.com/) for user authentication and storage. This interface ensures consistency and durability for essential information like:

- **User Accounts** 
- **Game State** 
- **Card Collections** 
- **Transaction Records** 
- **Story Progress & History** 

---

### Actions / Responsibilities

1. **Store User Data**  
   - Create new user records
   - Store minimal profile info (username, email, etc.) with the help of OAuth use
   - Maintain ban status if necessary
   - Store purchase status (accounts can be created before purchase)

2. **Store & Retrieve Game State**  
   - **Runs** (playthroughs): Current HP, mana, deck contents, progress through the story, etc.  
   - **Permanent Death**: Mark runs as inactive/completed upon the user’s HP reaching 0 (in line with Roguelike rules).
   - Multiplayer session info (if the user is playing co-op).

3. **Transaction Logs**  
   - Record successful or failed payment attempts from the **Payment Interface** (Stripe).
   - Update user access once purchases are confirmed.

4. **Game History & Analytics**  
   - Optionally store each finished run or partial logs for replay, analytics, or user records.
   - Keep track of user decisions or story branches.

5. **Card Collection Management**  
   - Store the user’s current deck: which cards they own, how many duplicates, any upgrades, etc.
   - Store global definitions for each type of card (Attack, Ability, Power) and link them to user decks.
   - Support card generation (as the cards are generated by AI, there shouldn't be a stored number of preset cards as new and unique cards being added will be a constant, although there should be a master table of all cards generated so far)

---

### Communication With Other Components

- **User Authentication Interface**  
  - **Reads/Writes** user data (account creation, OAuth tokens).
  - Verifies user has purchased the game before granting broader permissions.

- **Game Engine**  
  - **Retrieves** and **stores** user runs (HP, deck composition, current scenario).
  - Logs and updates combat states or story progress.

- **Card Management**  
  - **Saves** newly generated cards in the user’s deck.
  - **Reads** card definitions from a master list (e.g., from a `cards` table).
  - Updates deck composition upon collecting or removing cards.

- **Payment Interface**  
  - **Writes** transaction records for successful Stripe payments.
  - **Reads** user purchase status to confirm game access.

- **AI-Language Model Interface** (Optional)  
  - Log and retrieve narrative progress for story building.

- **AI Image Generation Interface** (Optional)  
  - Store references to generated images in the database (e.g., linking them to specific cards or enemies).
---
### Tables & Entities

#### 1. Users Table

- **Fields:**
  - `user_id` (PK)  
  - `email` or `username`  
  - `created_at`, `updated_at`  
  - `purchase_status` 

#### 2. Runs (Playthroughs)

- **Fields:**
  - `run_id` (PK)  
  - `user_id` (FK → `users.user_id`)  
  - `current_hp`, `max_hp`  
  - `mana_capacity`
  - `is_active` (bool) — **false** when the run ends (death)  
  - `started_at`, `ended_at`  
  - `status_effects` (JSON) to track non-combat statuses.  

#### 3. Cards

- **Fields:**
  - `card_id` (PK)  
  - `title`, `type` (Attack, Ability, Power)  
  - `mana_cost`  
  - `description` *(text)*  
  - `keywords` *(JSON or text)* — e.g., `["Damage(6)","Weakened(2)"]`  
  - `image_url` (for AI-generated images stored in AWS S3 Bucket)  
- **Notes:**  
  - This table is the **master list** of all card definitions.  
  - The actual user deck references these by `card_id`.

#### 4. Player_Cards (Decks)

- **Fields:**
  - `deck_entry_id` (PK)  
  - `run_id` (FK → `runs.run_id`)  
  - `card_id` (FK → `cards.card_id`) 
  - `user_id` (FK →  `users.user_id`) 
  - `quantity`  
- **Notes:**  
  - Many-to-many relationship: a run can have many cards, and a card can exist in many runs (with different quantities).  
  - This effectively tracks each run’s **deck** composition.

#### 5. Combat / Encounters

- **`combat` Table**  
  - `combat_id` (PK)  
  - `run_id` (FK)  
  - `is_active` (bool)  

- **`combat_participants` Table**  
  - `combat_id` (FK)  
  - `participant_id` (PK)  
  - `entity_type` (“player” or “enemy”)  
  - `entity_id` (points to either `users` or `enemies` if it’s an enemy type)  
  - `current_hp`  
  - `status_effects` (JSON)

- **`combat_actions` Table** (logging each turn)  
  - `action_id` (PK)  
  - `combat_id` (FK)  
  - `participant_id` (FK)  
  - `card_id` (FK or null)  
  - `action_type` (Attack, Defend, etc.)  
  - `details` (JSON: damage done, targets, etc.)  
  - `timestamp`

  - **`enemies` Table**:
  - `enemy_id ` (PK)   
  - `description`     
  - `status`  
  - `health`  

  - **`enemy_attacks` Table** 
  - `attack_id` (PK)
  - `keywords` *(JSON or text)* — e.g., `["Damage(6)","Weakened(2)"]`
  - `enemy_id` (FK) 
  - `animation_type` (Shake, Disappear, Charge, etc.)


#### 6. Payments / Transactions

- **Fields:**
  - `transaction_id` (PK)  
  - `user_id` (FK)  
  - `stripe_payment_id` or `transaction_ref`  
  - `amount`   
  - `status` (success, failed, etc.)  
  - `created_at`  
- **Notes:**  
  - The **Payment Interface** writes to this table upon receiving success/fail from Stripe.  
### Visualization of Tables
!["Database Layout"](databaseRoughLayout.png "Database Layout")

---



## 6. Security Design
This document was generated with the assistance of ChatGPT, which provided efficient and well-structured explanations for our chosen security measures. It helped articulate our reasoning more clearly and concisely than I could have expressed on my own, ensuring a thorough and well-documented approach to our security design.

### i. Authentication and Authorization
To secure user accounts and prevent unauthorized access, I chose **OAuth** for authentication. This is an industry-standard approach that removes the need for our game to store and manage passwords directly, reducing security risks.

- **OAuth Implementation:** Players will log in using trusted third-party authentication providers like Google, Microsoft, or Apple. This makes it easier for players to sign in without having to remember new credentials while also leveraging the security measures that these platforms already have in place.
- **Token-Based Authentication:** After a successful login, a short-lived access token will be issued, while a refresh token could be used to maintain session continuity. I chose this approach because it balances security and user convenience. This would keep users logged in without forcing them to re-login multiple times.
- **Two-Factor Authentication (2FA):** This will be an optional feature for users who want to add security, particularly for accounts with high in-game value. I included this because it mitigates account takeovers but won't be mandatory unless we store sensitive personal data like credit cards.

### ii. Data Protection & Privacy
Protecting player data is a top priority. I designed our approach based on encryption best practices and compliance with industry regulations.

- **Encryption of Sensitive Data:** Any personally identifiable information (PII) or game-related data will be encrypted where necessary. I chose this because it minimizes risks in case of data leaks while ensuring compliance with security standards.
- **Anonymized Analytics:** Analytics data will be aggregated and anonymized before storage to comply with regulations like GDPR and CCPA. This ensures that player data remains private while still allowing us to analyze game trends.
- **Secure Communication:** I chose TLS 1.3 encryption for client-server communication because it prevents eavesdropping and MITM (Man-in-the-Middle) attacks. TLS 1.3 is also faster than previous versions because it only requires one round trip instead of two. This is especially useful for multiplayer gaming, where latency matters.

### iii. Payment Security with Stripe
Since we could be handling in-game transactions, I decided to use Stripe as our payment processor.

- Stripe is a widely trusted payment provider with built-in security measures like PCI DSS compliance and fraud detection. It also supports multiple payment methods, including credit cards, Apple Pay, and Google Pay, making it easy for players to complete transactions securely.
- Instead of handling credit card details directly, we will use Stripe’s tokenization system to process payments securely. This means we never store sensitive payment data ourselves, reducing our security liability.
- Stripe includes real-time fraud detection, which helps prevent unauthorized transactions. I chose this because it adds an extra layer of security to in-game purchases and prevents chargebacks due to fraudulent activity.

### iv. Mitigating Common Attacks
Since online games are often targeted by cyber threats, I designed a set of security measures to protect our game from common attacks.

#### 1. DDoS Protection
DDoS attacks can cause major disruptions in multiplayer games, so I implemented multiple layers of defense:

- **Rate Limiting & Throttling:** Limits excessive requests from a single source to prevent bot-driven traffic spikes.
- **Traffic Monitoring & IP Filtering:** Detects unusual traffic patterns and blocks suspicious requests before they affect gameplay.
- **CDN & Load Balancing:** A Content Delivery Network (CDN) distributes game assets efficiently, and load balancing ensures fair distribution of incoming traffic across servers.

#### 2. SQL Injection & Input Validation
Malicious actors may attempt to manipulate game database queries via SQL injection. Preventative measures include:

- **Parameterized Queries & ORM (Object-Relational Mapping):** Using Django ORM or SQL ensures all user inputs are automatically sanitized before being used in queries.
- **Strict Input Validation:** We ensure that all user input (usernames, chat messages, deck names) is validated before being processed, reducing the risk of malicious data being injected.

#### 3. Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF)
To prevent unauthorized script execution and malicious actions via the web interface:

- **Content Security Policy (CSP):** Restricts execution of inline scripts and untrusted external sources. This prevents attackers from injecting harmful scripts into the game.
- **CSRF Tokens:** Every authenticated request requiring user action will include **unique CSRF tokens** to prevent unauthorized actions from malicious websites. This ensures that only requests originating from authorized users are accepted.

#### 4. Account Takeovers & Brute Force Attacks
To prevent attackers from guessing login credentials:

- **Account Lockouts & CAPTCHA:** After a certain number of failed login attempts, the system will **lock the account temporarily** and require a CAPTCHA verification. This makes it more difficult for attackers to use automated scripts to guess passwords.
- **IP Monitoring:** Repeated failed login attempts from a single IP will trigger **temporary bans** to deter brute-force attacks. This helps prevent attackers from systematically guessing login credentials.

#### 5. Prompt Injection Protection
Given the integration of AI-driven features, prompt injection attacks pose a potential threat where malicious inputs could manipulate AI responses:

- **Input Sanitization:** All user inputs interacting with AI components will undergo strict sanitization to remove harmful code or hidden instructions.
- **Context Isolation:** The AI’s processing context will be isolated, ensuring that user-generated content cannot alter system-level instructions or modify AI behavior unexpectedly.
- **Output Validation:** AI-generated outputs will be validated to detect and block any unauthorized commands or sensitive data disclosures before reaching the user interface.

### v. Secure Multiplayer & Fair Play
Since the game features **multiplayer components**, additional security measures are needed to **prevent cheating, exploits, and unauthorized modifications.**

- **Server-Side Game Logic Validation:** All crucial game logic (e.g., deck-building, in-game purchases) will be validated **on the server**, preventing client-side tampering. This ensures that users cannot manipulate game data on their own devices.
- **Cheat Detection Algorithms:** Player behavior will be **analyzed for anomalies**, such as **impossible win rates, artificially inflated resources, or modified game files.** This allows us to detect and prevent cheating.
- **Secure WebSocket Connections:** Multiplayer communication will use **secure WebSocket connections** with end-to-end encryption to prevent interception. This ensures that player interactions remain private and tamper-proof.

### vi. Disaster Recovery & Incident Response
A well-defined **disaster recovery plan** ensures security incidents are handled effectively:

- **Automated Backups:** Game data will be backed up **daily** with encrypted storage. This ensures that data can be restored in the event of a failure.
- **Incident Detection & Alerts:** Security incidents will trigger **real-time alerts**, allowing administrators to respond quickly. This ensures that any security threats are addressed as soon as they arise.
- **Post-Incident Audits:** All security events will be **logged** and **audited** to improve future security measures. This helps refine security strategies and prevent similar issues in the future.


## Conclusion

The security strategy outlined above ensures **robust protection against cyber threats** while maintaining a seamless user experience. By incorporating **OAuth authentication, encryption, DDoS protection, anti-cheat measures, and prompt injection defenses,** the game will be resilient to attacks, safeguarding both user data and gameplay integrity.


---


## 11. UI Design


### i. Hardware Platform


- **Primary Platform:** Web Application  
- **Target Devices:** Desktop and Tablet browsers (minimum viewport width 768px)  
- **Technology Stack:** React 18+, TypeScript, SASS
- **Supported Browsers:** Chrome 90+, Firefox 90+, Safari 14+, Edge 90+

  - **Rationale:** We are choosing Web application as our primary platform since this will reach the broadest audience. We are first prioritizing a wide aspect devices such as desktops and tablets but may make the game more mobile friendly once the core gameplay is polished. 


### ii. User Interface Design


### Branding & Theme


**Login and Theme Generator Color Scheme:**


- **Primary:** `#2D3748` (Dark Blue-Gray)
- **Secondary:** `#805AD5` (Purple)
- **Accent:** `#F6E05E` (Yellow)
- **Background:** `#1A202C` (Dark)
- **Text:** `#F7FAFC` (Light)


**Typography:**


- **Headings:** Inter  
- **Body:** Roboto Mono (for card text and game content)


**Design System:** Themes will be provided by AI (with parameters regarding contrast), based on the theme the user inputs


### iii. UI Flow

```mermaid
graph TD
    A[Main Menu] --> B[Theme Selection]
    B --> C[Game Session]
    C --> D[Battle View] --> F[Deck Management]
    C --> E[Text Input/AI Response] 
    C --> F[Deck Management]
    D --> G[Results Screen]
    G --> C
    G --> A
```

### iv. Input/Output Processing


#### Input Types


##### Text Commands
- Natural language input for game actions
- Card selection and play commands
- Navigation commands


##### Mouse/Touch Interactions
- Card dragging and dropping
- Button clicks
- Map navigation
- Menu selection

#### Output Types


##### Text Content
- AI-generated narrative
- Battle descriptions
- Card effects
- Event outcomes


##### Visual Elements
- Card Image renders
- Color theme generation


### v. Component Architecture


#### Core Components

```mermaid
graph TB
    
    
    subgraph "Game State Management"
        GameProvider --> ThemeContext
        GameProvider --> DeckContext
        GameProvider --> PlayerContext
    end
```


#### Internal Interfaces


#### Component Hierarchy

```mermaid
classDiagram
    class GameProvider {
        +theme: ThemeContext
        +deck: DeckContext
        +player: PlayerContext
        +updateGameState()
        +handleAction()
    }
    
    class Card {
        +id: string
        +name: string
        +effect: string
        +type: CardType
        +rarity: Rarity
        +play()
        +upgrade()
    }
    
    class BattleManager {
        +currentTurn: number
        +playerHealth: number
        +enemyState: EnemyState
        +playCard()
        +endTurn()
        +calculateDamage()
    }

  
    
    GameProvider --> Card
    GameProvider --> BattleManager
```




### vi. Implementation Strategy


#### Phase 1: Core Game Loop
- Basic UI components
- Card management system
- Battle mechanics
- Theme switching


#### Phase 2: AI Integration
- Text command processing
- Dynamic content generation
- Adaptive difficulty


#### Phase 3: Polish & Optimization
- Animation system
- Performance optimization
- Responsive design
- Accessibility features


---
